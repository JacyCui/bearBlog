---
title: 【离散数学与概率论-第4讲】稳定匹配
abbrlink: 11653
keywards: discrete-mathematics-and-probability-theory
tag: 离散数学与概率论
mathjax: true
date: 2022-09-02 21:08:23
description: 在前面两讲中，我们已经讨论了一些证明的技巧（直接证明、逆否法、反证法、例证法、归纳法）。在这一讲中，我们将会应用这些证明技巧中的一部分来分析“稳定匹配问题”的解决方案——“请求-拒绝算法”。
cover: https://s2.loli.net/2022/09/05/LQGbHAMn2sa5y3I.png
---


# 稳定匹配问题

在前面两讲中，我们已经讨论了一些证明的技巧（直接证明、逆否法、反证法、例证法、归纳法）。在这一讲中，我们将会应用这些证明技巧中的一部分来分析一个重要问题的解决方案。

这个问题叫做**稳定匹配问题(Stable Matching Problem)**，也是我们这一讲将要介绍的问题。稳定匹配问题也是算法领域中的焦点问题之一 。

## 引例

假设你在运行一个招聘系统，并且你的任务是将 $n$ 个工作和 $n$ 个候选人。每个工作都有都有一个对于合适的候选人的优先级列表，每个候选人也都有一个对于心怡的工作的优先级列表。

比如说，考虑 $n = 3$ 的情况，有3个工作：熊医生，熊老师，熊律师；并且有3个候选人：熊大, 熊二, 熊翠花。以及如下的优先级列表（列表的优先级从左往右是从最青睐的到最不青睐的顺序排的）

|工作|候选人|
|:-:|:-:|
|熊医生|熊大，熊二，熊翠花|
|熊老师|熊二，熊大，熊翠花|
|熊律师|熊大，熊二，熊翠花|

|候选人|工作|
|:-:|:-:|
|熊大|熊老师，熊医生，熊律师|
|熊二|熊医生，熊老师，熊律师|
|熊翠花|熊医生，熊老师，熊律师|

作为这个招聘系统的头儿，你想要做的事情是为每个职位匹配一个候选人。比如说，两种可能的匹配是： 

$$\{(熊医生, 熊大),(熊老师,熊二),(熊律师,熊翠花)\}$$ 
和 
$$\{(熊医生,熊二),(熊老师,熊翠花),(熊律师,熊大)\}$$

然而，你可能并不只是想做一个简单的匹配。为了使你的招聘系统成功，你希望这个系统给出的匹配结果能够让“每个人都满意”，也就是说没有人能够通过交换工作的方式来获取实际的好处，即“众有所归”。你能够高效的做到这件事情么？

> 我们可能并不能让每个人都最满意，但是我们可以尝试做到尽可能最好的结局，也就是说，如果有两个人想要换工作，那么他们只会更不满意。

事实上，确实有这样的算法来达到这个效果；此外，这个算法还特别简单快速且应用广泛。这个算法叫做**请求-拒绝算法(Propose-and-Reject Algorithm)**（也叫做Gale-Shapley Algorithm）。我们下面将会来展示这个算法。

# 请求-拒绝算法

## 算法

我们将算法视为是按“天”进行的，这样我们能够对于离散的时间有一个不模糊的，更清晰的感觉。

{% note simple %}

**每天早上：**每一个职位给自己最青睐的且还没有拒绝这个职位的候选人发offer。

**每天下午：**每一个求职者收集他早上收到的所有offer，对于所有的offer中他最喜欢的那一个（这个所有的offer也包括手上已经有的），他回复“可能”（先把这份offer放在手上考虑着），并且对于剩下的offer，他回复“不”（直接拒绝）。

> 这只是一种方式来模拟并没有爆炸性的offer（也就是求职者总是要考量一下的），并且职位给出offer后不能立即收回（刚给offer就收回的话，企业的信誉就太低了）。

**每天下午：**每个被拒绝的职位将拒绝自己的候选人从自己的列表中叉掉。

上述的循环将会一天天重复，直到没有offer被拒绝。在那个时候，每个求职者手上有一个offer，并且在这一天，每个求职者会接受他们手上的那个offer，然后算法终止。

{% endnote %}

## 示例

让我们通过在我们之前的例子上运行上述算法的方式来理解一下这个算法。下面的这张表展示了每天每个候选人收到的offer。

|天数|候选人|Offers|
|:-:|:-:|:-:|
|1|熊大|**熊医生**，熊律师|
||熊二|**熊老师**|
||熊翠花|-|
|2|熊大|**熊医生**|
||熊二|**熊老师**，熊律师|
||熊翠花|-|
|3|熊大|**熊医生**|
||熊二|**熊老师**|
||熊翠花|**熊律师**|

于是，我们的算法给出的匹配为：
$$\{(熊医生, 熊大),(熊老师,熊二),(熊律师,熊翠花)\}$$ 

在分析这个算法的性质之前，让我们花一点时间来问一个每当你遇到一个新概念的时候总应该问的首要问题之一：我们一开始为什么要研究稳定匹配？是什么使得它的解决方案如此的令人感兴趣？为了回答这些问题，我们下面会讨论Gale-Shapley算法在*住院医匹配项目(Residency Match Program)*中的实际影响。

# 住院医匹配项目

可能稳定匹配算法最知名的应用就是住院医匹配项目了，它会将医学院毕业生和教学医院的住院医师职位（实习）配对。毕业生和医院提交他们的排好序的优先级列表，然后由计算机产生一个稳定匹配来将学生和住院医师实习职位相匹配。

住院医师匹配项目的由来漫长而又曲折。住院医师项目是在大约一个世纪以前被引入的，因为实习为医院提供了一个廉价劳动力的来源，不久以后，实习岗位超过了医学院毕业生的数量，从而导致了激烈的竞争。医院们通过不断提早他们的实习offer的方式来争抢实习生。到了40年代中叶，住院实习的offer都开始向医学院大三学生发放了，有些医院甚至更早，都把offer发给大二学生了。

> 当然，他们只是拿到了offer，具体的实习应该还是要毕业之后才能去。

美国医学协会最终介入并禁止医学院在大四之前发布学生成绩单和推荐信（这样就没办法发offer，因为没有任何参考材料，毕竟不是谁都能要的）。这引发了一个新问题，医院现在提供“短线”offer，以确保如果他们的offer被拒绝，他们仍然可以找到替代实习生来填补空缺。医院之间的竞争再一次导致了一种无法接受的局面，学生们只有几个小时的时间来决定他们是否接受录取。

最后，在 1950 年代初期，这种不可持续的局面导致了称为全国住院医师匹配计划 (National Residency Matching Program, N.R.M.P.) 的集中式系统。在该系统中，医院对居民进行排名，居民对医院进行排名。 N.R.M.P.然后在申请人和医院之间建立了配对，尽管起初这种配对并不稳定。直到 1952 年，N.R.M.P.切换到 Propose-and-Reject 算法，导致匹配稳定。

最后，如果以上内容仍未让您相信该算法的价值，请考虑一下：2012 年，Lloyd Shapley 和 Alvin Roth 通过扩展 Propose-and-Reject 算法获得了诺贝尔经济学奖。（故事的寓意？仔细建模和适当的抽象是有回报的。）

# 请求-拒绝算法的性质

关于请求-拒绝算法，我们有两个性质想要证明：
- 第一：它不会永远执行下去，也就是说算法是能够终止的；
- 第二：它能够输出一个好的，也就是说稳定的匹配。

其中，前一个是很好说明的，我们现在就证明一下。

{% note orange 'fas fa-paperclip' flat %}
**引理4.1：**请求-拒绝算法总是能够终止。
{% endnote %}

{% hideToggle 引理4.1证明 %}
证明：论证很简单，在算法还没终止的每一天，至少有一个岗位从它的列表上排除了某个候选人（因为至少有一个候选人拒绝了某个岗位，否则算法就终止了）。由于每一个岗位的列表上一开始都有 $n$ 个候选人，一共有 $n$ 张列表，这意味着算法的迭代次数（过去的天数）肯定不超过 $n^2$ 。 $\square$
{% endhideToggle %}

下面，我们想要说明这个算法找到了一个“好”的匹配。在我们做这件事情之前，我们先阐明一下什么叫做“好”的匹配。

## 稳定性

### 探索

一个好的匹配应当具有怎样的性质呢？可能我们会想要尽量增大第一选择成功的数目，也就是让更多的人和医院得到自己最青睐的对方。再比如说，我们也可能想要减少最差选择的数量，即让更少的人和医院得到自己最不想要的对方。又或者，一个很理想的状态可能是我们让选择排名的和的值尽可能小（比如说大家都选到了第一志愿，那么选择排名的和只有 $n$ ；如果大家都选到了第 $n$ 志愿，那么选择排名的和就会是 $n^2$ 了，我们应该尽量让大家选到靠前的，更满意的志愿），这可以看作是一种平均化的满意程度。

在这一讲中，我们将关注一个更基本的标准，它植根于自治的概念，即*稳定性(stability)*。一个匹配是**不稳定的(unstable)**，如果存在一个工作和一个候选人，相比于他们现有的匹配，他们都更青睐对方。我们称这样的一对为**流氓夫妇(rogue couple)**（他们会抛弃现有的配偶搞在一起）。所以，如果 $n$ 个工作和 $n$ 个候选人的匹配中没有任何流氓夫妇的存在，那么我们认为它是**稳定的(stable)** 。

下面让我们回顾一下之前的例子：

|工作|候选人|
|:-:|:-:|
|熊医生|熊大，熊二，熊翠花|
|熊老师|熊二，熊大，熊翠花|
|熊律师|熊大，熊二，熊翠花|

|候选人|工作|
|:-:|:-:|
|熊大|熊老师，熊医生，熊律师|
|熊二|熊医生，熊老师，熊律师|
|熊翠花|熊医生，熊老师，熊律师|

> 概念检查：考虑对于上述例子的下面一种匹配，为什么它是不稳定的？
> $$\{(熊医生，熊翠花)，(熊老师，熊二)，(熊律师，熊大)\}$$
> （提示：熊医生和熊二是一对流氓夫妇——为什么？）

这是我们示例的稳定匹配：
$$\{(熊老师, 熊大), (熊医生, 熊二), (熊律师, 熊翠花)\}$$

为什么（熊医生，熊大）在这里不是流氓夫妇？ 熊医生确实宁愿让熊大来当，也不愿给现任员工熊二来当。然而不幸的是，熊大更喜欢当前的工作熊老师，而不是当熊医生。另请注意，熊律师和熊翠花在此匹配中都与他们最不青睐的选择配对。尽管如此，这并没有违反稳定性，因为他们更青睐的选择中没有一个更愿意选择他们，这些人都更满意自己当前的匹配。所以，尽管熊律师这个职位不青睐熊翠花，熊翠花也不想当熊律师，但也没有选择了。

### 思考

在我们讨论如何找到一个稳定匹配之前，让我们问一个更基础的问题：稳定匹配总是存在么？答案显然是对的，因为我们可以从任意一个匹配开始，并似乎可以通过如下的方式使得这个匹配越来越稳定：如果存在一个流氓夫妇，修改现有的匹配是的这两个流氓夫妇匹配在一起，重复上述步骤。

那么，这个过程一定会导致一个稳定匹配吗？不幸的是，这个背后的原因并不是很显然的。为什么？尽管将流氓夫妇配对能够将流氓夫妇的数量减一，但是它也有可能会产生新的流氓夫妇。所以，这个过程会终止到现在为止还并不是清晰的事情。

让我们通过将其应用于一个密切相关的场景，即*室友问题(Roomates Problem)*来进一步说明上述推理的谬误。在这个问题中，我们有 $2n$ 个人必须成对组成室友（区别是和我们之前稳定匹配的视角下只能匹配不对称的另一种类型的对方不同，一个人可以和其他 $2n-1$ 个人匹配，也就是类型上并没有非对称性）。

现在，假设我们迭代地匹配流氓夫妇的方法确实有效。由于这个方法其实并没有用到非对称性，我们同样可以将这个方法应用在室友问题上。于是，我们能够得到结论：对于室友问题一定存在一个稳定匹配。之后，你会惊奇的看到一个反例，它是一个室友问题的例子，但是却不存在稳定匹配，从而说明迭代地匹配流氓夫妇的方法并不有效。

|人|第1优先室友|第2优先室友|第3优先室友|
|:-:|:-:|:-:|:-:|
|**A**|B|C|D|
|**B**|C|A|D|
|**C**|A|B|D|
|**D**|-|-|-|

在这个例子当中，对于任意的匹配，都存在一对流氓夫妇。比如说 $\{(A,B),(C,D)\}$ 包含流氓夫妇 $B$ 和 $C$ 。 那么 $\{(B,C),(A,D)\}$ 呢？这个匹配也是不稳定的，因为这个时候 $A$ 和 $C$ 成了流氓夫妇。

> 概念检查：确认在这个例子中不存在稳定匹配。（提示：暴力穷举就可以了，总共也就3种情况）

### 总结

根据上面的过程，我们可以得出一个结论，任何一个想要证明稳定匹配问题中一定存在稳定匹配的证明必定要使用到存在两种不同的类型这个条件，否则我们总能通过上述的反例来说如果没有非对称性的前提，有可能不存在稳定匹配。

在下一个小节中，我们会给出一个这样的证明，并且是一个很令人舒适的证明：我们会证明一定存在一个稳定匹配，因为请求-拒绝算法总能够输出一个稳定匹配。

## 分析

### 直观地算法过程分析及其形式化证明

我们现在开始证明请求拒绝算法总能输出一个稳定匹配。为什么这样呢？先考虑一下下面这个符合直觉的观察：

{% note purple 'fas fa-eye' flat %}
**观察4.1：**每项工作都以可能的第一选择开始算法；然而，随着算法的进行，它的最佳可用选项只会随着时间的推移而变得更糟。相比之下，每个候选人得到的offer只会随着时间的推移而变得更好。
{% endnote %}

于是，随着算法的推进，岗位的选项变得越来越糟糕，而候选人的offer变得越来越好；在某个特定的一点处，岗位和候选人会在中间“相遇”，且直觉上，这个时刻的匹配应当是稳定的。

让我们将这个直觉形式化一下，通过下面的这个引理证明一个正式的关于观察4.1的语句。

{% note orange 'fas fa-paperclip' flat %}
**引理4.2（改进引理）：**如果工作J在第k天向候选人C发出offer，那么后续的每一天，C手头都有一个offer，他至少和J一样喜欢。
{% endnote %}

> 至少和J一样喜欢的含义是已经有了J的offer，有可能留下比J更喜欢的offer，不会留下比J更不喜欢的offer。

{% hideToggle 引理4.2证明 %}
证明：对天数 $i$ 进行归纳，其中 $i\ge k$ 。

基础情况（ $i = k$ ）：在第 $k$ 天， $C$ 收到了至少一个来自于 $J$ 的offer。在第 $k$ 天结束的时候，他手上会留下一份offer，要么就是 $J$ ，要么是一个比 $J$ 更喜欢的offer，因为根据算法，他会选择收到的所有offer中最喜欢的一个留下来。

归纳假设：假设结论对于某个 $i \ge k$ 成立。

归纳步骤：下面证明结论对于第 $k + 1$ 天成了。根据归纳假设，在第 $i$ 天， $C$ 手上留下了一个工作 $J'$ 的offer，他对 $J'$ 至少和 对 $J$ 一样喜欢（ $J'$ 有可能就是 $J$ ）。

根据算法， $J'$ 会在第$k + 1$ 天再次给 $C$ 发offer（因为这个offer并没有被拒绝，也不允许收回，也不会爆炸消失）。因此，在第 $i + 1$ 天结束的时候， $C$ 手上要么就是 $J'$ ，要么是一个比 $J'$ 更喜欢的offer。在这两种情况下，他都至少和 $J$ 一样喜欢。于是结论对于 $k + 1$ 成立，归纳步骤完成。

综上，由归纳原则，引理4.2证毕。 $\square$
{% endhideToggle %}

### 补充良序原理

**下面我们绕路去看一下良序原理。**

让我们花一点时间来考虑引理4.2的另一种证明方法，在这个过程中，我们会涵盖一个基本的原理，这个原理和归纳是等价的。

{% hideToggle 引理4.2另证 %}

证明：和原本的证明一样，原命题在第 $i = k$ 天的时候是显然成立的。为了产生矛盾，假设第 $i$ 天（ $i > k$ ）是第一个反例，在这一天 $C$ 要么没有收到offer或者留下了一个offer $J^{\*}$ ，但是这个offer还不如 $J$ 喜欢。在第 $i - 1$ 天，他手上有一个offer $J'$ 至少是和 $J$ 一样喜欢的。

根据算法过程， $J'$ 在第 $i$ 天依旧会给 $C$ 发offer（也就是说offer不会爆炸消失，也不能被收回）。所以 $C$ 在第 $i$ 天至少有一个选择 $J'$ ；于是，他的最好选择一定至少和 $J'$ 一样好，从而一定比 $J^{\*}$ 或者啥也没有好，这个和我们的假设是矛盾的。

于是，不存在任何反例，原命题成立。 $\square$

{% endhideToggle %}

在上面的证明中我们使用了什么证明方法呢？是反证法吗？还是些什么别的全新的数学野兽？其实，这也是一种归纳法。为什么呢？

我们从建立基础情况 $i = k$ 开始。接下来，我们没有证明 $\forall i, P(i)\Longrightarrow P(i+1)$ ，我们证明了这个命题的否定是假的，也就是说证明 $\exists i, \neg(P(i)\Longrightarrow P(i+1))$ 不成立。

从而，根据排中律，$\forall P(i)\Longrightarrow P(i+1)$ 就成立了。

> 概念检查：请确保你理解了为什么上面的两种证明方法是等价的。

现在，让我们更小心翼翼一些——到底是什么让我们能够采取后面那种替代方案呢？这个问题的答案在于一个非常特殊的自然数的性质，叫做**良序原理（Well-Ordering Principle）**。这个原理是说任意一个非空的自然数的集合中都存在一个最小的元素。正式地说：

{% note pink 'fas fa-book' flat %}
**定义4.1（良序原理）：** 如果 $S\subseteq\mathbb{N}$ 且 $S\ne\emptyset$ ，那么 $S$ 有一个最小的元素。
{% endnote %}

> 概念检查：考虑下面的几个自然数集的子集：$S_1 = \{5, 2, 11, 7, 8\}$ ， $S_2 = \{n\in\mathbb{N} : n\ is\ odd\}$ ， $S_3 = \{n\in\mathbb{N}: n\ is\ prime\}$ 。这些集合都有一个最小的元素吗？

在我们的证明中到底哪个地方用到了良序原理呢？在这一句话中：“为了产生矛盾，假设第 $i$ 天（ $i > k$ ）是第一个反例”，如果自然数并不遵循良序原理，那么所谓的“第一个”反例的说法就无从存在了。

值得注意的是，归纳法也依赖于这个原理：$\forall i, P(i)\Longrightarrow P(i+1)$ 只有当自然数本身具有定义良好的顺序的时候才是有意义的（定义良好的顺序指的是3在4前面，4在5前面这样的关系）。

自然数遵循良序原理可能是你长期以来想当然就觉得正确的一个事实，但是并不是所有的数集都满足良序性质的。从这个层面上来讲，自然数确实很特殊。

> 概念检查：整数集满足良序原理吗？实数集呢？非负实数集呢？

**回到我们对于请求-拒绝算法的分析。**

### 算法的终止和结果的稳定性

我们现在来证明当算法终止的时候，所有的 $n$ 个候选人都得到了自己的offer。在阅读证明之前，先看看你自己能否说服自己这是真的。这个证明过程非常的简单优雅，并且很关键地用到了改进引理。

{% note orange 'fas fa-paperclip' flat %}
**引理4.3：**请求-拒绝算法终止的时候总是能产生一个匹配。
{% endnote %}

{% hideToggle 引理4.3证明 %}

证明：反证法。假设存在一个工作 $J$ 在算法终止的时候未匹配到候选人。它一定已经给它列表上所有的 $n$ 位候选人都发了offer且被所有人都拒绝了（否则算法不会终止）。根据改进引理，由于它的offer被拒绝了，$n$ 个候选人中的每一个人都有了一个比 $J$ 更好的offer，考虑到 $J$ 已经给他们每个人都发过offer了。于是，当算法终止的时候，$n$ 个候选人有了 $n$ 个不包含 $J$ 的工作（每个候选人都有一个工作，否则他不会拒绝，算法也不会终止），从而至少要有 $n + 1$ 个工作。但这是一个矛盾，因为我们只有 $n$ 个职位。

{% endhideToggle %}

为了完成我们对于请求-拒绝算法的分析，我们需要确认最关键的性质，就是算法产生的匹配是稳定匹配。

{% note blue 'fas fa-ruler' flat %}
**定理4.1：**请求-拒绝算法产生的匹配是总是稳定的。
{% endnote %}

{% hideToggle 引理4.3证明 %}

证明：我们下面给出一个直接证明，在算法输出的匹配当中，没有任何工作会成为流氓夫妇的一员。

考虑最终匹配中的任意一个夫妇 $(J, C)$ 且假设 $J$ 比起 $C$ 更青睐某个候选人 $C^{\*}$ 。我们将会论证 $C^{\*}$ 比起 $J$ 会更喜欢自己现有的工作，从而 $(J, C^{\*})$ 不可能是一对流氓夫妇。

由于在 $J$ 的列表中，$C^{\*}$ 在 $C$ 的前面，根据算法过程， $J$ 一定在给 $C$ 发offer之前就已经给 $C^{\*}$ 发过offer了。从而，根据改进引理， $C^{\*}$ 会喜欢他的最终工作，至少像喜欢 $J$ 一样，并且因此他更喜欢当前的工作（因为当前工作不是 $J$ ，所以只会更喜欢）。

综上，任意的一个工作 $J$ 都不会是流氓夫妇的一员，所以匹配是稳定的。 $\square$

{% endhideToggle %}

注意，我们证明稳定性是从工作的视角来证明的，而不是从候选人的视角。

# 最优性

## 引入

在4.2节中，我们论证了请求-拒绝算法总是能够输出一个稳定匹配。但这真的如此的让人惊叹吗？输出一个稳定的匹配就足以让你的招聘系统成功了吗？为了提供最好的服务（并代替现有的方法），你会理想地想要去追求你获得的解决方案的*最优性(optimality)*。

例如，考虑下面的4份工作和4个候选人及其优先级的情况（为了表示简单，我们用数字和字母来表示工作和候选人）：

|工作|候选人优先级排序||候选人|工作优先级排序|
|:-:|:-:|-|:-:|:-:|
|1|A B C D||A|1 3 2 4|
|2|A D C B||B|4 3 2 1|
|3|A C B D||C|2 3 1 4|
|4|A B C D||D|3 4 2 1|

对于这个例子，恰有两个稳定匹配：$S = \{(1,A), (2,D), (3,C), (4,B)\}$ 和 $T = \{(1,A), (2,C), (3,D), (4,B)\}$ 。

有两个稳定匹配的事实就又提出了一些新的问题：对于每个候选人来说，有可能的最好的工作是什么？对于每个工作来说，有可能的最好的候选人又是谁？

## 候选人和岗位的最优性

比如说，让我们考虑一下工作2。最简单的猜想是2的最优候选人A，但不幸的是让A做这份工作是不现实的，因为将2和A匹配会变得不稳定，因为这个工作在A的优先级中太靠后了，而其他的工作也青睐A。实际上，不存在稳定匹配将2和A匹配到一起。（也就是如果让A干2，必然会跳槽）

评估两个稳定匹配，我们发现对于工作2来说，最好的结果应当是和候选人 $D$ 匹配到一起。这说明了最好的对方的表示可能有一些模糊，如果我们不小心谨慎的话。

所以，让我们小心一些。受上面的讨论启发，让我们给最优性下一个准确且站得住脚的定义。

{% note pink 'fas fa-book' flat %}
**定义4.2（一个工作的最优候选人）：**对于一个给定的工作 $J$ ，它的最优候选人是所有的稳定匹配中可以和 $J$ 匹配的人中，在 $J$ 的优先级列表上排名最高的那个人。
{% endnote %}

换句话说，最优的候选人是一个岗位在保证稳定匹配的前提下能够招到的最青睐的人。

> 概念检查：在上面的例子中，对于每个工作来说，最优的候选人是谁？（提示：我们已经讨论过，对于工作2来说，最优的候选人是D）

根据定义，对于一个岗位来说，它最好的希望就是和它的最优候选人匹配。但是，所有的岗位能够同时和自己的最优候选人匹配吗？换句话说，存在某个稳定匹配，使得每一个工作都和自己的最优候选人匹配在一起吗？如果这样的匹配存在，我们会称之为一个*工作最优匹配(job/employer optimal matching)*。

回到上面那个例子， $S$ 是一个工作最优匹配，因为A是1的最优候选人，D是2的最优候选人，C是3的最优候选人，且B是4的最优候选人。

类似的，我们可以为每个候选人定义一个最优的岗位。

{% note pink 'fas fa-book' flat %}
**定义4.3（一个候选人的最优工作）：**对于一个给定的候选人 $C$ ，它的最优工作是所有的稳定匹配中可以和 $C$ 匹配的工作中，在 $C$ 的优先级列表上排名最高的那个工作。
{% endnote %}

换句话说，最优工作是一个候选人在保证稳定匹配的前提下能够得到的最中意的工作。

我们可以定义一个*候选人最优匹配(candidate optimal matching)*，在这个匹配中，每个候选人都和自己的最优工作匹配了。

> 概念检查：检查一下 $T$ 是否是一个候选人最优匹配。

我们也可以向相反方向走，定义一个工作的*最差候选人(pessimal)*是稳定匹配中对于这个工作来讲排名最低的候选人。于是，我们会有*工作最差匹配(employer pessimal matching)*的表示，你能定义它么？类似地，你可以的也定义一下*候选人最差匹配(candidate pessimal matching)*吗？

## 请求拒绝算法的最优性

现在，我们更接近事情的心脏了：在请求-拒绝算法当中，谁会更受益呢？工作（或者说老板），还是候选人（或者说求职者）？

{% note blue 'fas fa-ruler' flat %}
**定理4.2：**请求-拒绝算法输出的匹配是工作最优匹配。
{% endnote %}

{% hideToggle 定理4.2证明 %}

证明：反证法。

假设算法输出的匹配不是工作最优的，那么存在某些天，在这些天当中，某个工作发出的offer被它的最优候选人给拒绝了，记这些天中的第一天为整个算法的第 $k$ 天。

在这一天中，设 $J$ 被它的最优候选人 $C^{\*}$ 因为更想要 $J^{\*}$ 的offer给拒绝了。根据最优候选人的定义，一定存在一个稳定匹配 $T$ ，在此之中 $J$ 和 $C^{\*}$ 是匹配在一起的。

假设 $T$ 形如： $\{..., (J, C^{\*}), (J^{\*}, C'), ...\}$ 。我们将会论证 $(J^{\*}, C^{\*})$ 是一对流氓夫妇，从而和 $T$ 的稳定性矛盾。

首先，$C^{\*}$ 相比于 $J$ 更青睐 $J^{\*}$ 是显然的，因为 $C^{\*}$ 为了 $J^{\*}$ 而拒绝了 $J$ 。

此外，由于第 $k$ 天是第一天有工作最优候选人拒绝，在第 $k$ 天之前，工作$J^{\*}$还并没有被自己的最优候选人给拒绝。由于 $J^{\*}$ 在第 $k$ 天给 $C^{\*}$ 发offer了，这意味着 $J^{\*}$ 喜欢 $C^{\*}$ 至少像它的最优候选人那样，从而是至少像 $C'$ 那样（因为$C'$ 最多也就是最优候选人了，不会更优了）。

但显然，$C^{\*}\ne C'$，所以 $J^{\*}$ 比起 $C'$ 更喜欢 $C^{\*}$。

于是， $(J^{\*}, C^{\*})$ 形成了一个 $T$ 中的流氓夫妇，这与 $T$ 是稳定匹配是矛盾的。

综上，请求-拒绝算法输出的匹配是工作最优的。
{% endhideToggle %}

证明定理4.2的时候我们用了什么证明方法呢？虽然看起来是反证法，但其实还是归纳法，应用了良序原理，考虑算法过程中不优情况出现的第一天。

> 概念检查：在定理4.2的证明中，哪个地方用到了良序原理呢？

> 练习：你可以用普通的归纳法重写定理4.2的证明吗？（提示：对 $k$ 进行归纳来证明：对于每个 $k$ ，没有任何工作在第 $k$ 天被它的最优候选人给拒绝。）

我们现在可以得出结论，招聘者在这个算法中会非常受益。那么，求职者呢？下面的定理确认了一个悲伤的真相：

{% note blue 'fas fa-ruler' flat %}
**定理4.3：**如果一个匹配是工作最优的，那么它也是候选人最差的。
{% endnote %}

{% hideToggle 定理4.3证明 %}

证明：反证法。令 $T = \{..., (J, C), ...\}$ 为工作最优匹配（从定理4.2中我们知道，请求-拒绝算法会输出这样的匹配）。假设存在一个稳定匹配 $S = \{..., (J^{\*}, C), ..., (J, C'), ...\}$ 使得工作 $J^{*}$ 在 $C'$ 的优先级列表中低于 $J$ （也就是说 $J$ 不是 $C$ 的最差选择）。

我们将会通过说明 $(J, C)$ 是一对流氓夫妇来论证 $S$ 不可能是稳定匹配，从而导出矛盾。

根据假设， $C$ 相比于 $J^{\*}$ 更喜欢 $J$ 。并且 $J$ 相比于 $C'$ 更喜欢 $C$ ，因为 $C$ 是 $J$ 的最优匹配。于是 $(J,C)$ 是一对流氓夫妇。

综上，定理4.3成立。 $\square$

{% endhideToggle %}

鉴于这些发现，请求-拒绝算法教给我们什么？制度结构对结果的分配质量有很大影响，制度结构反映了现实世界的权力及其历史。

> 练习：你能够对请求拒绝算法做出一些修改，从而使得它总能够输出一个候选人最优匹配吗？(提示：呼唤请求者和拒绝者的角色)

让我们以关于国家住院医匹配计划的一些最终评论作为结束。直到最近，请求-拒绝算法都是在医院进行请求的情况下运行的，因此产生的匹配是医院最优的。九十年代，角色互换，医学生向医院请求。最近，N.R.M.P. 对用过的算法进行了其他改进，例如，匹配考虑了已婚学生在同一家或附近医院的职位偏好。

# 练习题

在进行后面的习题之前，我们稍微正式的写一下请求-拒绝算法的伪代码：

![propose-reject-algorithm](https://s2.loli.net/2022/09/05/gXqn1DxW7ZjMb5O.png)

<!--
    \begin{algorithm}
    \caption{Propose-Reject-Algorithm}
    \begin{algorithmic}
    \INPUT A set of Jobs and a set of Candidates and the priority list of each job and each candidate.
    \OUTPUT A stable and job/employer optimal matching of jobs and candidates.
    \STATE \COMMENT{Define some notations for the algorithm.}
    \STATE Let job.candidates denote the priority list of a job.
    \STATE Let candidate.jobs denote the priority list of a candidate.
    \STATE Let candidate.offers denote the set of offers received by a candidate.
    \STATE Let candidate.choice denote the choice of job made by a candidate.
    \STATE
    \STATE rejected $:=$ \TRUE
    \WHILE{rejected}
        \STATE \COMMENT{The procedure of propose. }
        \FOR{\textbf{each} job \textbf{in} Jobs}
            \STATE Send an offer of the job to the top-ranked candidate in job.candidates.
        \ENDFOR
        \STATE
        \STATE \COMMENT{The procedure of reject. }
        \STATE rejected $=$ \FALSE
        \FOR{\textbf{each} candidate \textbf{in} Candidates}
            \IF{candidate.offers \textbf{is} \NOT empty}
                \STATE Let bestOffer be the best offer in candidate.offers.
                \STATE \COMMENT{The best offer among candidate.offers is the one}
                \STATE \COMMENT{from the job that has the highest rank in candidate.jobs.}
                \STATE Remove bestOffer from candidate.offers.
                \STATE candidate.choice $=$ bestOffer
                \FOR{\textbf{each} offer \textbf{in} candidate.offers sent \textbf{by} job}
                    \STATE \COMMENT{Reject extra offers.}
                    \STATE Remove candidate from job.candidates.
                    \STATE rejected $=$ \TRUE
                \ENDFOR
                \STATE Clear candidate.offers.
            \ENDIF
        \ENDFOR
    \ENDWHILE
    \STATE
    \STATE \COMMENT{Out put the result.}
    \STATE Let StableMatch be an empty set.
    \FOR{\textbf{each} candidate \textbf{in} Candidates}
        \STATE Insert (candidate.choice, candidate) into StableMatch.
    \ENDFOR
    \RETURN StableMatch
    \end{algorithmic}
    \end{algorithm}
-->



## 稳定匹配

考虑候选者集合 $C = \{1, 2, 3\}$ 与工作集合 $J = \{A, B, C\}$ ，优先级列表如下：

|C|J||J|C|
|:-:|:-:|-|:-:|:-:|
|1|A B C||A|2 1 3|
|2|B A C||B|1 2 3|
|3|A B C||C|1 2 3|

在这个例子上运行请求-拒绝算法，需要花多少天才能完成匹配，以及匹配结果是什么？（请展示你的过程）

{% hideToggle 解答 %}

|天数|候选者|Offers|
|:-:|:-:|:-:|
|1|1|**B**, C|
||2|**A**|
||3||
|2|1|**B**|
||2|**A**, C|
||3||
|3|1|**B**|
||2|**A**|
||3|**C**|

{% endhideToggle %}


## 好，更好，最好

在某个特定的稳定匹配问题的实例中，有 $n$ 个申请者和 $n$ 个工作，结果存在 $3$ 个不同的稳定匹配， $S_1$ ， $S_2$ 和 $S_3$ 。并且，每个申请者在这 $3$ 个稳定匹配都有一个不同的匹配对象。于是，每个申请人对这 $3$ 个稳定匹配都有一个清晰的偏好顺序（根据他的匹配对象在他优先级列表中的排名）。现在，假设对于申请人 $m_1$ ，这个顺序是 $S_1 > S_2 > S_3$ 。

证明每一个申请人都有相同的偏好顺序 $S_1 > S_2 > S_3$ 。

> 提示：回忆一下工作最优匹配总是存在的，并且可以通过工作请求匹配算法生成。通过翻转稳定匹配算法的角色，让申请人请求，工作负责拒绝，这样的话我们能够生成一个怎样的匹配呢？

{% hideToggle 解答 %}

证明：我们已经在前面证明了请求-拒绝算法能够生成请求者最优的稳定匹配（定理4.2）。将申请人作为请求者，工作作为拒绝着运行请求-拒绝算法，可以得到申请人最优的稳定匹配。而对于 $m_1$ 来说， $S_1 > S_2 > S_3$ ，则 $S_1$ 就是申请人最优的稳定匹配。

类似的，将工作作为请求者，申请人作为拒绝着运行请求-拒绝算法，可以得到工作最优匹配，而工作最优匹配就是申请人最差匹配（定理4.3）。而对于 $m_1$ 来说， $S_1 > S_2 > S_3$ ，则 $S_3$ 就是申请人最差匹配。

由于 $S_1$ 是申请人最优匹配， $S_3$ 是申请人最差匹配，所以，对于每个申请人，都会有 $S_1 > S_2 > S_3$ 。

{% endhideToggle %}

# 作业题

> 作业题后续更新。


{% note green 'fas fa-check' flat %}
恭喜完成离散数学与概率论第4讲《稳定匹配》所有内容的学习！
{% endnote %}

